// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/ONSdigital/dp-cache"
	"sync"
)

var (
	lockCacherMockAddUpdateFunc sync.RWMutex
	lockCacherMockClose         sync.RWMutex
	lockCacherMockGet           sync.RWMutex
	lockCacherMockSet           sync.RWMutex
	lockCacherMockStartUpdates  sync.RWMutex
)

// Ensure, that CacherMock does implement cache.Cacher.
// If this is not the case, regenerate this file with moq.
var _ cache.Cacher = &CacherMock{}

// CacherMock is a mock implementation of cache.Cacher.
//
//     func TestSomethingThatUsesCacher(t *testing.T) {
//
//         // make and configure a mocked cache.Cacher
//         mockedCacher := &CacherMock{
//             AddUpdateFuncFunc: func(key string, updateFunc func() (interface{}, error))  {
// 	               panic("mock out the AddUpdateFunc method")
//             },
//             CloseFunc: func()  {
// 	               panic("mock out the Close method")
//             },
//             GetFunc: func(key string) (interface{}, bool) {
// 	               panic("mock out the Get method")
//             },
//             SetFunc: func(key string, data interface{})  {
// 	               panic("mock out the Set method")
//             },
//             StartUpdatesFunc: func(ctx context.Context, channel chan error)  {
// 	               panic("mock out the StartUpdates method")
//             },
//         }
//
//         // use mockedCacher in code that requires cache.Cacher
//         // and then make assertions.
//
//     }
type CacherMock struct {
	// AddUpdateFuncFunc mocks the AddUpdateFunc method.
	AddUpdateFuncFunc func(key string, updateFunc func() (interface{}, error))

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// GetFunc mocks the Get method.
	GetFunc func(key string) (interface{}, bool)

	// SetFunc mocks the Set method.
	SetFunc func(key string, data interface{})

	// StartUpdatesFunc mocks the StartUpdates method.
	StartUpdatesFunc func(ctx context.Context, channel chan error)

	// calls tracks calls to the methods.
	calls struct {
		// AddUpdateFunc holds details about calls to the AddUpdateFunc method.
		AddUpdateFunc []struct {
			// Key is the key argument value.
			Key string
			// UpdateFunc is the updateFunc argument value.
			UpdateFunc func() (interface{}, error)
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key string
			// Data is the data argument value.
			Data interface{}
		}
		// StartUpdates holds details about calls to the StartUpdates method.
		StartUpdates []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel chan error
		}
	}
}

// AddUpdateFunc calls AddUpdateFuncFunc.
func (mock *CacherMock) AddUpdateFunc(key string, updateFunc func() (interface{}, error)) {
	if mock.AddUpdateFuncFunc == nil {
		panic("CacherMock.AddUpdateFuncFunc: method is nil but Cacher.AddUpdateFunc was just called")
	}
	callInfo := struct {
		Key        string
		UpdateFunc func() (interface{}, error)
	}{
		Key:        key,
		UpdateFunc: updateFunc,
	}
	lockCacherMockAddUpdateFunc.Lock()
	mock.calls.AddUpdateFunc = append(mock.calls.AddUpdateFunc, callInfo)
	lockCacherMockAddUpdateFunc.Unlock()
	mock.AddUpdateFuncFunc(key, updateFunc)
}

// AddUpdateFuncCalls gets all the calls that were made to AddUpdateFunc.
// Check the length with:
//     len(mockedCacher.AddUpdateFuncCalls())
func (mock *CacherMock) AddUpdateFuncCalls() []struct {
	Key        string
	UpdateFunc func() (interface{}, error)
} {
	var calls []struct {
		Key        string
		UpdateFunc func() (interface{}, error)
	}
	lockCacherMockAddUpdateFunc.RLock()
	calls = mock.calls.AddUpdateFunc
	lockCacherMockAddUpdateFunc.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *CacherMock) Close() {
	if mock.CloseFunc == nil {
		panic("CacherMock.CloseFunc: method is nil but Cacher.Close was just called")
	}
	callInfo := struct {
	}{}
	lockCacherMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockCacherMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedCacher.CloseCalls())
func (mock *CacherMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockCacherMockClose.RLock()
	calls = mock.calls.Close
	lockCacherMockClose.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *CacherMock) Get(key string) (interface{}, bool) {
	if mock.GetFunc == nil {
		panic("CacherMock.GetFunc: method is nil but Cacher.Get was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	lockCacherMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockCacherMockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedCacher.GetCalls())
func (mock *CacherMock) GetCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	lockCacherMockGet.RLock()
	calls = mock.calls.Get
	lockCacherMockGet.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *CacherMock) Set(key string, data interface{}) {
	if mock.SetFunc == nil {
		panic("CacherMock.SetFunc: method is nil but Cacher.Set was just called")
	}
	callInfo := struct {
		Key  string
		Data interface{}
	}{
		Key:  key,
		Data: data,
	}
	lockCacherMockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	lockCacherMockSet.Unlock()
	mock.SetFunc(key, data)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//     len(mockedCacher.SetCalls())
func (mock *CacherMock) SetCalls() []struct {
	Key  string
	Data interface{}
} {
	var calls []struct {
		Key  string
		Data interface{}
	}
	lockCacherMockSet.RLock()
	calls = mock.calls.Set
	lockCacherMockSet.RUnlock()
	return calls
}

// StartUpdates calls StartUpdatesFunc.
func (mock *CacherMock) StartUpdates(ctx context.Context, channel chan error) {
	if mock.StartUpdatesFunc == nil {
		panic("CacherMock.StartUpdatesFunc: method is nil but Cacher.StartUpdates was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Channel chan error
	}{
		Ctx:     ctx,
		Channel: channel,
	}
	lockCacherMockStartUpdates.Lock()
	mock.calls.StartUpdates = append(mock.calls.StartUpdates, callInfo)
	lockCacherMockStartUpdates.Unlock()
	mock.StartUpdatesFunc(ctx, channel)
}

// StartUpdatesCalls gets all the calls that were made to StartUpdates.
// Check the length with:
//     len(mockedCacher.StartUpdatesCalls())
func (mock *CacherMock) StartUpdatesCalls() []struct {
	Ctx     context.Context
	Channel chan error
} {
	var calls []struct {
		Ctx     context.Context
		Channel chan error
	}
	lockCacherMockStartUpdates.RLock()
	calls = mock.calls.StartUpdates
	lockCacherMockStartUpdates.RUnlock()
	return calls
}
